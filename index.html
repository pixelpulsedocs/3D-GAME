<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Open World Collision Physics</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background-color: #87CEEB; touch-action: none; user-select: none; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        
        #info-bar { 
            background: rgba(0, 0, 0, 0.9); 
            color: white; 
            padding: 10px 20px; 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            border-bottom: 2px solid #e1b12c; 
            pointer-events: auto;
        }
        
        .header-btn {
            background: #e1b12c; color: #000; border: none; padding: 8px 15px; border-radius: 5px; font-weight: bold; cursor: pointer; font-size: 12px; text-transform: uppercase; box-shadow: 0 0 10px rgba(225, 177, 44, 0.5); transition: all 0.2s;
        }
        .header-btn:hover { transform: scale(1.05); background: #fff; }
        
        /* Dashboard */
        #dashboard {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            width: 220px; background: rgba(0,0,0,0.85); border: 2px solid #e1b12c; border-radius: 15px; padding: 15px; text-align: center; color: #fff; font-family: 'Courier New', monospace; display: none;
        }
        #gear-display { font-size: 50px; font-weight: bold; color: #e1b12c; margin-bottom: 5px; text-shadow: 0 0 10px #e1b12c; }
        #speed-display { font-size: 20px; color: #fff; font-weight: bold; }
        #controls-hint-drive { font-size: 10px; color: #aaa; margin-top: 5px; }
        
        #rpm-bar { width: 100%; height: 8px; background: #333; margin-top: 8px; border-radius: 4px; overflow: hidden; }
        #rpm-fill { height: 100%; width: 0%; background: linear-gradient(90deg, #00b894, #fdcb6e, #d63031); transition: width 0.1s; }

        /* Mobile Controls */
        .gear-btn { position: absolute; bottom: 140px; width: 60px; height: 60px; background: rgba(255, 255, 255, 0.1); border: 2px solid #e1b12c; border-radius: 10px; color: #e1b12c; font-size: 24px; font-weight: bold; display: flex; justify-content: center; align-items: center; pointer-events: auto; cursor: pointer; backdrop-filter: blur(4px); }
        .gear-btn:active { background: rgba(225, 177, 44, 0.8); color: #000; }
        #gear-up { right: 20px; } #gear-down { right: 90px; }

        #action-prompt { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.85); color: #0ff; padding: 15px 30px; border-radius: 30px; font-size: 20px; font-weight: bold; border: 2px solid #0ff; display: none; animation: pulse 1.5s infinite; transition: all 0.5s ease; text-align: center; white-space: nowrap; }
        #action-prompt.driving-mode { top: 75%; transform: translate(-50%, 0); font-size: 14px; padding: 8px 20px; border-width: 1px; background: rgba(0, 0, 0, 0.5); animation: none; }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(0, 255, 255, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(0, 255, 255, 0); } 100% { box-shadow: 0 0 0 0 rgba(0, 255, 255, 0); } }

        #controls-container { padding: 20px; pointer-events: auto; display: flex; justify-content: space-between; align-items: flex-end; }
        .d-pad { position: relative; width: 150px; height: 150px; }
        .action-pad { display: flex; gap: 15px; flex-direction: column; align-items: center; }
        .ctrl-btn { background: rgba(255, 255, 255, 0.2); border: 2px solid rgba(255, 255, 255, 0.5); border-radius: 50%; width: 60px; height: 60px; display: flex; justify-content: center; align-items: center; color: white; font-size: 24px; cursor: pointer; transition: background 0.1s; backdrop-filter: blur(2px); box-shadow: 0 4px 6px rgba(0,0,0,0.3); }
        .ctrl-btn:active, .ctrl-btn.active { background: rgba(255, 255, 255, 0.6); transform: scale(0.95); color: #333; }
        #btn-up { position: absolute; top: 0; left: 45px; } #btn-down { position: absolute; bottom: 0; left: 45px; } #btn-left { position: absolute; top: 45px; left: 0; } #btn-right { position: absolute; top: 45px; right: 0; }
        .special-btn { width: 70px; height: 70px; border-radius: 20px; font-size: 14px; font-weight: bold; }
        #btn-enter { border-color: #0ff; color: #0ff; }
        
        #loader { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #111; color: #e1b12c; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 999; font-family: 'Courier New', monospace; }
        #status-msg { position: absolute; top: 70px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: #00d2d3; padding: 10px 20px; border-radius: 20px; font-weight: bold; display: none; z-index: 100; text-align: center; }
        #help-tip { position: absolute; top: 60px; right: 20px; background: rgba(0,0,0,0.6); color: #aaa; padding: 5px 10px; border-radius: 5px; font-size: 11px; pointer-events: none; text-align: right; }
    </style>
</head>
<body>

    <div id="loader">
        <h1 style="font-size: 30px; margin-bottom: 10px;">INITIALIZING PHYSICS...</h1>
        <div id="loader-text">Building Colliders...</div>
    </div>
    
    <div id="status-msg">Ready!</div>
    
    <div id="help-tip" class="hidden-mobile">
        DRIVING:<br>
        W = Gas | S = Brake<br>
        1-6 = Gears | R = Reverse | N = Neutral<br>
        PageUp/Down = Fix Height
    </div>

    <div id="ui-layer">
        <div id="info-bar">
            <div style="font-weight: bold; font-size: 18px;">Pro Driving Sim</div>
            <input type="file" id="file-input" accept=".glb,.gltf" style="display: none;">
            <button class="header-btn" onclick="document.getElementById('file-input').click()">ðŸ“‚ Import Car</button>
        </div>
        
        <!-- Dashboard -->
        <div id="dashboard">
            <div id="gear-display">N</div>
            <div id="speed-display">0 km/h</div>
            <div id="rpm-bar"><div id="rpm-fill"></div></div>
            <div id="controls-hint-drive">W: Gas | S: Brake</div>
        </div>

        <!-- Mobile Gear Controls -->
        <div id="gear-controls" style="display:none;">
            <div class="gear-btn" id="gear-up">G+</div>
            <div class="gear-btn" id="gear-down">G-</div>
        </div>
        
        <div id="action-prompt">PRESS 'E' TO DRIVE</div>
        
        <div id="controls-container">
            <div class="d-pad">
                <div class="ctrl-btn" id="btn-up">W</div><div class="ctrl-btn" id="btn-left">A</div><div class="ctrl-btn" id="btn-right">D</div><div class="ctrl-btn" id="btn-down">S</div>
            </div>
            <div class="action-pad">
                <div class="ctrl-btn special-btn" id="btn-enter" style="display:none;">ENTER</div>
                <div class="ctrl-btn special-btn" id="btn-jump">JUMP</div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            walkSpeed: 0.15, runSpeed: 0.35, turnSpeed: 0.08, jumpForce: 0.5, gravity: 0.02,
            worldSize: 600, roadWidth: 14, blockSize: 70,
            
            gearRatios: {
                'R': { maxSpeed: 0.6, accel: 0.04 },
                'N': { maxSpeed: 0.0, accel: 0.0 },
                '1': { maxSpeed: 0.8, accel: 0.08 },
                '2': { maxSpeed: 1.4, accel: 0.07 },
                '3': { maxSpeed: 2.0, accel: 0.06 },
                '4': { maxSpeed: 2.6, accel: 0.05 },
                '5': { maxSpeed: 3.2, accel: 0.04 },
                '6': { maxSpeed: 4.0, accel: 0.035 }
            },
            
            carTurnSpeed: 0.05,
            carFriction: 0.98,
            carBrakePower: 0.08,
            carScale: 1.5,
            carYOffset: 0.8, 
            manualHeightAdj: 0
        };

        // --- GLOBALS ---
        let scene, camera, renderer;
        let player, playerBody, leftLeg, rightLeg, leftArm, rightArm, head;
        let cars = [], npcs = [], buildingTextures = [];
        let colliders = []; // NEW: Array to store things we can crash into
        let activeCar = null, isDriving = false, nearbyCar = null;
        
        let input = { gas: false, brake: false, left: false, right: false, jump: false, run: false };
        let playerVelocity = new THREE.Vector3(), isGrounded = false, animationTime = 0;
        
        let currentGear = 'N'; 
        let engineRPM = 0; 
        
        let loadedCarModel = null; 
        const gltfLoader = new THREE.GLTFLoader();

        // UI Elements
        const loaderEl = document.getElementById('loader');
        const statusMsg = document.getElementById('status-msg');
        const actionPrompt = document.getElementById('action-prompt');
        const btnEnter = document.getElementById('btn-enter');
        const btnJump = document.getElementById('btn-jump');
        const fileInput = document.getElementById('file-input');
        const dashboard = document.getElementById('dashboard');
        const gearDisplay = document.getElementById('gear-display');
        const speedDisplay = document.getElementById('speed-display');
        const rpmFill = document.getElementById('rpm-fill');
        const gearControls = document.getElementById('gear-controls');

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 150);
            
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, -10);

            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.body.appendChild(renderer.domElement);

            const ambLight = new THREE.AmbientLight(0xffffff, 0.7); scene.add(ambLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
            dirLight.position.set(60, 120, 50); dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048; dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            generateBuildingTextures();
            createGround();
            createRoads();
            generateBuildings();
            generateEnvironment();
            createPlayer();
            spawnNPCs(20);
            spawnCars(15); 
            
            setupInputs();
            setupFileLoader();
            setupGearUI();
            
            window.addEventListener('resize', onWindowResize);
            setTimeout(() => { loaderEl.style.display = 'none'; }, 1000);
            animate();
        }

        // --- ASSETS & WORLD GENERATION (Updated with Collisions) ---
        function generateBuildingTextures() {
            const createTexture = (color) => {
                const c = document.createElement('canvas'); c.width = 64; c.height = 128;
                const ctx = c.getContext('2d'); ctx.fillStyle = color; ctx.fillRect(0,0,64,128);
                for(let y=10; y<120; y+=20) for(let x=10; x<60; x+=20) { ctx.fillStyle = Math.random()>0.3?'#222':'#ffffaa'; ctx.fillRect(x,y,10,15); }
                const t = new THREE.CanvasTexture(c); t.magFilter = THREE.NearestFilter; return t;
            };
            buildingTextures.push(createTexture('#556677')); buildingTextures.push(createTexture('#775555'));
            buildingTextures.push(createTexture('#666666')); buildingTextures.push(createTexture('#444455'));
        }
        function createGround() { const g = new THREE.Mesh(new THREE.PlaneGeometry(CONFIG.worldSize, CONFIG.worldSize), new THREE.MeshPhongMaterial({ color: 0x5fa052 })); g.rotation.x = -Math.PI/2; g.receiveShadow = true; scene.add(g); }
        function createRoads() {
            const rMat = new THREE.MeshPhongMaterial({ color: 0x222222 }); const sMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const h = CONFIG.worldSize/2;
            for(let x=-h; x<h; x+=CONFIG.blockSize) createRoadSegment(rMat, sMat, CONFIG.roadWidth, CONFIG.worldSize, x, 0);
            for(let z=-h; z<h; z+=CONFIG.blockSize) createRoadSegment(rMat, sMat, CONFIG.worldSize, CONFIG.roadWidth, 0, z);
        }
        function createRoadSegment(rm, sm, w, h, x, z) {
            const r = new THREE.Mesh(new THREE.PlaneGeometry(w, h), rm); r.rotation.x = -Math.PI/2; r.position.set(x, 0.02, z); r.receiveShadow = true; scene.add(r);
            if(w>h) for(let i=-h/2; i<h/2; i+=8) { const d=new THREE.Mesh(new THREE.PlaneGeometry(3,0.5),sm); d.rotation.x=-Math.PI/2; d.position.set(i,0.03,z); scene.add(d); }
            else for(let i=-h/2; i<h/2; i+=8) { const d=new THREE.Mesh(new THREE.PlaneGeometry(0.5,3),sm); d.rotation.x=-Math.PI/2; d.position.set(x,0.03,i); scene.add(d); }
        }
        function generateBuildings() {
            const h = CONFIG.worldSize/2;
            for(let x=-h+CONFIG.blockSize/2; x<h; x+=CONFIG.blockSize) for(let z=-h+CONFIG.blockSize/2; z<h; z+=CONFIG.blockSize) {
                if(Math.abs(x)<40 && Math.abs(z)<40) continue;
                if(Math.random()>0.4) {
                    const ht = 10+Math.random()*40, wd=15+Math.random()*10, dp=15+Math.random()*10;
                    const tex = buildingTextures[Math.floor(Math.random()*buildingTextures.length)];
                    const b = new THREE.Mesh(new THREE.BoxGeometry(wd,ht,dp), [new THREE.MeshLambertMaterial({map:tex}),new THREE.MeshLambertMaterial({map:tex}),new THREE.MeshLambertMaterial({color:0x333}),new THREE.MeshLambertMaterial({color:0x333}),new THREE.MeshLambertMaterial({map:tex}),new THREE.MeshLambertMaterial({map:tex})]);
                    b.position.set(x, ht/2, z); b.castShadow = true; b.receiveShadow = true; 
                    scene.add(b);
                    
                    // Add to Physics World
                    // Use a Box3 for simple collision detection
                    const box = new THREE.Box3().setFromObject(b);
                    colliders.push(box);
                }
            }
        }
        function generateEnvironment() {
            const tg = new THREE.ConeGeometry(2,6,8), trg = new THREE.CylinderGeometry(0.5,0.5,2,8);
            const tm = new THREE.MeshPhongMaterial({color:0x2e7d32}), trm = new THREE.MeshPhongMaterial({color:0x5d4037});
            for(let i=0; i<150; i++) {
                const x=(Math.random()-0.5)*CONFIG.worldSize, z=(Math.random()-0.5)*CONFIG.worldSize;
                if(Math.abs(x%CONFIG.blockSize)<CONFIG.roadWidth/2+3 || Math.abs(z%CONFIG.blockSize)<CONFIG.roadWidth/2+3) continue;
                if(Math.abs(x%CONFIG.blockSize)>10 && Math.abs(x%CONFIG.blockSize)<60 && Math.abs(z%CONFIG.blockSize)>10 && Math.abs(z%CONFIG.blockSize)<60) continue;
                
                const t = new THREE.Mesh(trg,trm); t.position.set(x,1,z); t.castShadow=true; 
                const l = new THREE.Mesh(tg,tm); l.position.set(0,4,0); l.castShadow=true; t.add(l); 
                scene.add(t);
                
                // Add Tree Trunk to Colliders (Small Box)
                const trunkBox = new THREE.Box3().setFromCenterAndSize(new THREE.Vector3(x, 1, z), new THREE.Vector3(1, 2, 1));
                colliders.push(trunkBox);
            }
        }

        // --- CAR & PLAYER ---
        function setupFileLoader() {
            fileInput.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;
                showStatus("Processing Model...", "#e1b12c");
                const url = URL.createObjectURL(file);
                gltfLoader.load(url, (gltf) => {
                    loadedCarModel = gltf.scene;
                    loadedCarModel.traverse((child) => { if (child.isMesh) { child.castShadow = true; child.receiveShadow = true; } });
                    const box = new THREE.Box3().setFromObject(loadedCarModel);
                    const size = new THREE.Vector3(); box.getSize(size);
                    const maxDim = Math.max(size.x, size.y, size.z);
                    CONFIG.carScale = 4.5 / maxDim;
                    CONFIG.manualHeightAdj = 0;
                    showStatus("Car Imported! (PageUp/Down to fix height)", "#00b894");
                    respawnCars();
                }, undefined, (error) => { console.error(error); showStatus("Error loading file", "#d63031"); });
            });
        }
        function showStatus(text, color) { statusMsg.innerText = text; statusMsg.style.color = color; statusMsg.style.display = 'block'; setTimeout(() => { statusMsg.style.display = 'none'; }, 4000); }
        function respawnCars() { cars.forEach(c => scene.remove(c)); cars = []; spawnCars(15); }
        function spawnCars(count) {
            const carColors = [0xd63031, 0xfdcb6e, 0x2d3436, 0x0984e3, 0xdfe6e9];
            for (let i = 0; i < count; i++) {
                let x, z, found=false;
                while(!found) {
                    const isVertical = Math.random() > 0.5;
                    if(isVertical) { x = Math.floor((Math.random() - 0.5) * (CONFIG.worldSize / CONFIG.blockSize)) * CONFIG.blockSize; z = (Math.random() - 0.5) * CONFIG.worldSize; }
                    else { z = Math.floor((Math.random() - 0.5) * (CONFIG.worldSize / CONFIG.blockSize)) * CONFIG.blockSize; x = (Math.random() - 0.5) * CONFIG.worldSize; }
                    if(Math.abs(x) > 20 || Math.abs(z) > 20) found = true;
                }
                const color = carColors[Math.floor(Math.random() * carColors.length)];
                createCar(x, z, color);
            }
        }
        function createCar(x, z, color) {
            const carGroup = new THREE.Group();
            carGroup.position.set(x, CONFIG.carYOffset + CONFIG.manualHeightAdj, z);
            const isVertical = Math.abs(x % CONFIG.blockSize) < 5;
            carGroup.rotation.y = isVertical ? 0 : -Math.PI/2;
            if (loadedCarModel) {
                const model = loadedCarModel.clone(); model.scale.set(CONFIG.carScale, CONFIG.carScale, CONFIG.carScale); model.rotation.y = 0;
                model.traverse((child) => {
                    if (child.isMesh && (child.material.name.toLowerCase().includes('paint') || child.material.name.toLowerCase().includes('body'))) {
                        child.material = child.material.clone(); child.material.color.setHex(color);
                    }
                });
                carGroup.add(model); addCarLights(carGroup, 0.8, 1.8);
            } else { createProceduralMustang(carGroup, color); }
            carGroup.userData = { speed: 0, steering: 0, type: 'car' };
            scene.add(carGroup); cars.push(carGroup);
        }
        function createProceduralMustang(group, color) {
            group.position.y = 0.45;
            const bodyMat = new THREE.MeshPhongMaterial({ color: color, shininess: 80 });
            const glassMat = new THREE.MeshPhongMaterial({ color: 0x111111, shininess: 100 });
            const wheelMat = new THREE.MeshPhongMaterial({ color: 0x111111 });
            const chassis = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.6, 5), bodyMat); chassis.position.y = 0.4; group.add(chassis);
            const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.9, 0.5, 2.5), glassMat); cabin.position.set(0, 0.95, -0.2); group.add(cabin);
            const scoop = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.1, 1.5), bodyMat); scoop.position.set(0, 0.75, 1.2); group.add(scoop);
            const spoiler = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.1, 0.6), bodyMat); spoiler.position.set(0, 1.0, -2.4); group.add(spoiler);
            const wGeo = new THREE.CylinderGeometry(0.45, 0.45, 0.4, 16);
            const addW = (dx, dz) => { const w = new THREE.Mesh(wGeo, wheelMat); w.rotation.z = Math.PI/2; w.position.set(dx, 0.45, dz); group.add(w); };
            addW(1.1, 1.4); addW(-1.1, 1.4); addW(1.1, -1.4); addW(-1.1, -1.4);
            addCarLights(group, 0.6, 2.5);
        }
        function addCarLights(group, height, zPos) {
            const lightTarget = new THREE.Object3D(); lightTarget.position.set(0, 0, 20); group.add(lightTarget);
            const spotL = new THREE.SpotLight(0xffffff, 2, 50, 0.6, 0.5); spotL.position.set(0, height + 0.5, 0); spotL.target = lightTarget; group.add(spotL);
        }
        function createPlayer() {
            player = new THREE.Group();
            const sm = new THREE.MeshPhongMaterial({color:0xffcc80}), shm = new THREE.MeshPhongMaterial({color:0xff4757}), pm = new THREE.MeshPhongMaterial({color:0x2f3542});
            playerBody = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1, 0.4), shm); playerBody.position.y = 1.5; playerBody.castShadow = true; player.add(playerBody);
            head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), sm); head.position.y = 0.8; playerBody.add(head);
            leftLeg = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1, 0.3), pm); leftLeg.position.set(-0.2, -1, 0); playerBody.add(leftLeg);
            rightLeg = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1, 0.3), pm); rightLeg.position.set(0.2, -1, 0); playerBody.add(rightLeg);
            leftArm = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.9, 0.25), sm); leftArm.position.set(-0.55, 0.1, 0); playerBody.add(leftArm);
            rightArm = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.9, 0.25), sm); rightArm.position.set(0.55, 0.1, 0); playerBody.add(rightArm);
            scene.add(player);
        }

        // --- NPC LOGIC ---
        function spawnNPCs(count) {
            const cols=[0xFF5733,0x33FF57,0x3357FF,0xF3FF33,0xFF33F3];
            for(let i=0;i<count;i++) {
                let x,z,dir,found=false;
                while(!found) {
                    const isV=Math.random()>0.5, off=CONFIG.roadWidth/2+2;
                    if(isV) { x=Math.floor((Math.random()-0.5)*(CONFIG.worldSize/CONFIG.blockSize))*CONFIG.blockSize+(Math.random()>0.5?off:-off); z=(Math.random()-0.5)*100; dir='z'; }
                    else { z=Math.floor((Math.random()-0.5)*(CONFIG.worldSize/CONFIG.blockSize))*CONFIG.blockSize+(Math.random()>0.5?off:-off); x=(Math.random()-0.5)*100; dir='x'; }
                    if(Math.abs(x)>10||Math.abs(z)>10) found=true;
                }
                const n=new THREE.Group(); n.position.set(x,1.5,z);
                const mat=new THREE.MeshPhongMaterial({color:cols[Math.floor(Math.random()*cols.length)]});
                n.add(new THREE.Mesh(new THREE.BoxGeometry(0.7,0.9,0.4),mat));
                const h=new THREE.Mesh(new THREE.BoxGeometry(0.4,0.4,0.4),new THREE.MeshPhongMaterial({color:0xffcc80})); h.position.y=0.7; n.add(h);
                const lg=new THREE.BoxGeometry(0.25,0.9,0.25), lm=new THREE.MeshPhongMaterial({color:0x222});
                const ll=new THREE.Mesh(lg,lm); ll.position.set(-0.2,-0.9,0); n.add(ll); const rl=new THREE.Mesh(lg,lm); rl.position.set(0.2,-0.9,0); n.add(rl);
                n.userData={axis:dir,speed:0.05+Math.random()*0.05,dir:Math.random()>0.5?1:-1,anim:Math.random()*100,ll:ll,rl:rl,s:dir==='x'?x:z};
                if(dir==='x') n.rotation.y=n.userData.dir===1?Math.PI/2:-Math.PI/2; else n.rotation.y=n.userData.dir===1?0:Math.PI;
                scene.add(n); npcs.push(n);
            }
        }

        function setGear(gear) {
            currentGear = gear;
            gearDisplay.innerText = gear;
            gearDisplay.style.color = (gear === 'N' || gear === 'R') ? '#d63031' : '#e1b12c';
            showStatus(`Gear: ${gear}`, "#e1b12c");
        }

        function cycleGear(direction) {
            const gears = ['R', 'N', '1', '2', '3', '4', '5', '6'];
            let idx = gears.indexOf(currentGear);
            if (direction === 'up' && idx < gears.length - 1) idx++;
            if (direction === 'down' && idx > 0) idx--;
            setGear(gears[idx]);
        }

        function handleInteraction() { if(isDriving) exitCar(); else if(nearbyCar) enterCar(nearbyCar); }
        function enterCar(c) {
            isDriving=true; activeCar=c; player.visible=false; player.position.copy(c.position);
            actionPrompt.innerText="Press 'E' to Exit"; actionPrompt.classList.add('driving-mode'); btnJump.style.display='none'; btnEnter.innerText="EXIT";
            dashboard.style.display = 'block'; gearControls.style.display = 'block'; currentGear = 'N'; gearDisplay.innerText = 'N';
        }
        function exitCar() {
            if(!activeCar) return;
            isDriving=false; player.visible=true;
            const off=new THREE.Vector3(2,0,0).applyAxisAngle(new THREE.Vector3(0,1,0),activeCar.rotation.y);
            player.position.copy(activeCar.position).add(off); player.rotation.y=activeCar.rotation.y; player.position.y=0;
            activeCar.userData.speed=0; activeCar=null;
            actionPrompt.innerText="PRESS 'E' TO DRIVE"; actionPrompt.classList.remove('driving-mode'); btnJump.style.display='flex'; btnEnter.innerText="ENTER"; btnEnter.style.display='none';
            dashboard.style.display = 'none'; gearControls.style.display = 'none';
        }
        function adjustCarHeight(delta) {
            CONFIG.manualHeightAdj += delta;
            showStatus(`Height Adj: ${CONFIG.manualHeightAdj.toFixed(2)}`, "#aaa");
            cars.forEach(c => { c.position.y += delta; });
        }

        // --- NEW: COLLISION CHECK FUNCTION ---
        function checkCollision(object, isCar = false) {
            // Create a small bounding box for the dynamic object at its current position
            // For Car: 2x1x4.5 box approx
            // For Player: 1x2x1 box approx
            const size = isCar ? new THREE.Vector3(2, 2, 4.5) : new THREE.Vector3(0.8, 2, 0.8);
            
            // Adjust box center slightly up
            const center = object.position.clone();
            center.y += 1; 
            
            const dynamicBox = new THREE.Box3().setFromCenterAndSize(center, size);
            
            // Iterate over all static colliders
            for (let i = 0; i < colliders.length; i++) {
                if (dynamicBox.intersectsBox(colliders[i])) {
                    return true;
                }
            }
            return false;
        }

        // --- UPDATED GAME LOOP ---
        function updateGame() {
            if(isDriving && activeCar) {
                // Save previous position
                const prevPos = activeCar.position.clone();
                const prevRot = activeCar.rotation.clone();

                const d = activeCar.userData;
                const gearInfo = CONFIG.gearRatios[currentGear];
                
                if (currentGear === 'N') {
                    if(input.gas) engineRPM = Math.min(engineRPM + 5, 100); else engineRPM = Math.max(engineRPM - 2, 10);
                    d.speed *= 0.98;
                }
                else if (currentGear === 'R') {
                    if (input.gas) { if (d.speed > -gearInfo.maxSpeed) { d.speed -= gearInfo.accel; engineRPM = (Math.abs(d.speed) / gearInfo.maxSpeed) * 80 + 10; } }
                    if (input.brake) { if (d.speed < 0) d.speed += CONFIG.carBrakePower; if (d.speed > 0) d.speed = 0; }
                    if (!input.gas && !input.brake) { d.speed *= CONFIG.carFriction; engineRPM = Math.max(engineRPM - 2, 10); }
                } 
                else {
                    if (input.gas) {
                        if (d.speed < gearInfo.maxSpeed) { d.speed += gearInfo.accel; engineRPM = (d.speed / gearInfo.maxSpeed) * 85 + 15; } 
                        else { engineRPM = 95 + Math.random() * 5; }
                    }
                    if (input.brake) { if (d.speed > 0) d.speed -= CONFIG.carBrakePower; if (d.speed < 0) d.speed = 0; }
                    if (!input.gas && !input.brake) { d.speed *= CONFIG.carFriction; engineRPM = Math.max(engineRPM - 2, 10); }
                }
                
                if(Math.abs(d.speed)>0.01) { 
                    const dir = d.speed > 0 ? 1 : -1; 
                    activeCar.rotation.y += (input.left ? CONFIG.carTurnSpeed : (input.right ? -CONFIG.carTurnSpeed : 0)) * dir; 
                }
                
                activeCar.translateZ(d.speed); 
                player.position.copy(activeCar.position);
                
                // NEW: Collision Check for Car
                if (checkCollision(activeCar, true)) {
                    // Revert position
                    activeCar.position.copy(prevPos);
                    activeCar.rotation.copy(prevRot); // Also revert rotation to prevent sticking
                    
                    // Crash physics
                    if (Math.abs(d.speed) > 0.3) {
                        // Big crash
                        d.speed = -d.speed * 0.3; // Bounce back
                        showStatus("CRASH!", "#ff0000");
                    } else {
                        d.speed = 0; // Just stop
                    }
                }
                
                speedDisplay.innerText = Math.abs(Math.round(d.speed * 100)) + " km/h";
                rpmFill.style.width = engineRPM + "%";
                rpmFill.style.background = engineRPM > 90 ? '#d63031' : '#00b894';

                camera.position.lerp(new THREE.Vector3(0,8,-18).applyMatrix4(activeCar.matrixWorld), 0.1); 
                camera.lookAt(activeCar.position.clone().add(new THREE.Vector3(0,1,0)));
            } else {
                // Player movement
                const prevPos = player.position.clone();
                const s=input.run?CONFIG.runSpeed:CONFIG.walkSpeed;
                if(input.left) player.rotation.y+=CONFIG.turnSpeed; if(input.right) player.rotation.y-=CONFIG.turnSpeed;
                const d=new THREE.Vector3(0,0,1).applyAxisAngle(new THREE.Vector3(0,1,0),player.rotation.y);
                
                if(input.gas) { player.position.addScaledVector(d,s); animateWalk(true); } 
                else if(input.brake) { player.position.addScaledVector(d,-s*0.5); animateWalk(true); } 
                else animateWalk(false);
                
                // NEW: Collision Check for Player
                if (checkCollision(player, false)) {
                    player.position.copy(prevPos); // Stop if hitting wall
                }
                
                if(input.jump && isGrounded) { playerVelocity.y=CONFIG.jumpForce; isGrounded=false; }
                playerVelocity.y-=CONFIG.gravity; player.position.y+=playerVelocity.y;
                if(player.position.y<=0) { player.position.y=0; playerVelocity.y=0; isGrounded=true; }
                
                let cd=Infinity, cc=null;
                cars.forEach(c=>{const dist=player.position.distanceTo(c.position); if(dist<4 && dist<cd){cd=dist;cc=c;}});
                nearbyCar=cc;
                if(nearbyCar) { actionPrompt.style.display='block'; actionPrompt.innerText="PRESS 'E' TO DRIVE"; actionPrompt.classList.remove('driving-mode'); btnEnter.style.display='flex'; btnEnter.innerText="ENTER"; } else { actionPrompt.style.display='none'; btnEnter.style.display='none'; }
                camera.position.lerp(new THREE.Vector3(0,5,-8).applyMatrix4(player.matrixWorld), 0.1); camera.lookAt(player.position.clone().add(new THREE.Vector3(0,2,0)));
            }
            npcs.forEach(n=>{
                const d=n.userData;
                if(d.axis==='x') { n.position.x+=d.speed*d.dir; if(Math.abs(n.position.x-d.s)>40) {d.dir*=-1; n.rotation.y=d.dir===1?Math.PI/2:-Math.PI/2;} } else { n.position.z+=d.speed*d.dir; if(Math.abs(n.position.z-d.s)>40) {d.dir*=-1; n.rotation.y=d.dir===1?0:Math.PI;} }
                d.anim+=0.2; d.ll.rotation.x=Math.sin(d.anim)*0.5; d.rl.rotation.x=Math.sin(d.anim+Math.PI)*0.5;
            });
        }
        function animateWalk(m) { if(m) { animationTime+=0.2; leftLeg.rotation.x=Math.sin(animationTime)*0.6; rightLeg.rotation.x=Math.sin(animationTime+Math.PI)*0.6; leftArm.rotation.x=Math.sin(animationTime+Math.PI)*0.6; rightArm.rotation.x=Math.sin(animationTime)*0.6; } else { leftLeg.rotation.x=0; rightLeg.rotation.x=0; leftArm.rotation.x=0; rightArm.rotation.x=0; } }
        
        function setupGearUI() {
            document.getElementById('gear-up').addEventListener('click', () => cycleGear('up'));
            document.getElementById('gear-down').addEventListener('click', () => cycleGear('down'));
            const addTouch = (id, fn) => {
                const el = document.getElementById(id);
                el.addEventListener('touchstart', (e) => { e.preventDefault(); fn(); el.classList.add('active'); });
                el.addEventListener('touchend', (e) => { e.preventDefault(); el.classList.remove('active'); });
            };
            addTouch('gear-up', () => cycleGear('up'));
            addTouch('gear-down', () => cycleGear('down'));
        }

        function setupInputs() {
            document.addEventListener('keydown',e=>{ 
                if(e.code==='KeyW'||e.code==='ArrowUp') input.gas=true; 
                if(e.code==='KeyS'||e.code==='ArrowDown') input.brake=true; 
                if(e.code==='KeyA'||e.code==='ArrowLeft') input.left=true; 
                if(e.code==='KeyD'||e.code==='ArrowRight') input.right=true; 
                if(e.code==='Space') input.jump=true; 
                if(e.code==='ShiftLeft') input.run=true; 
                if(e.code==='KeyE') handleInteraction();
                if(e.code==='PageUp') adjustCarHeight(0.1);
                if(e.code==='PageDown') adjustCarHeight(-0.1);
                
                if(isDriving) {
                    if(e.key === '1') setGear('1');
                    if(e.key === '2') setGear('2');
                    if(e.key === '3') setGear('3');
                    if(e.key === '4') setGear('4');
                    if(e.key === '5') setGear('5');
                    if(e.key === '6') setGear('6');
                    if(e.key.toLowerCase() === 'n') setGear('N');
                    if(e.key.toLowerCase() === 'r') setGear('R');
                    if(e.key.toLowerCase() === 'q') setGear('1');
                }
            });
            document.addEventListener('keyup',e=>{ 
                if(e.code==='KeyW'||e.code==='ArrowUp') input.gas=false; 
                if(e.code==='KeyS'||e.code==='ArrowDown') input.brake=false; 
                if(e.code==='KeyA'||e.code==='ArrowLeft') input.left=false; 
                if(e.code==='KeyD'||e.code==='ArrowRight') input.right=false; 
                if(e.code==='Space') input.jump=false; 
                if(e.code==='ShiftLeft') input.run=false; 
            });
            const touch=(id,k)=>{ const el=document.getElementById(id); el.addEventListener('touchstart',e=>{e.preventDefault();input[k]=true;el.classList.add('active')}); el.addEventListener('touchend',e=>{e.preventDefault();input[k]=false;el.classList.remove('active')}); el.addEventListener('mousedown',e=>{input[k]=true;el.classList.add('active')}); el.addEventListener('mouseup',e=>{input[k]=false;el.classList.remove('active')}); };
            touch('btn-up','gas'); touch('btn-down','brake'); touch('btn-left','left'); touch('btn-right','right'); touch('btn-jump','jump');
            const be=document.getElementById('btn-enter'); be.addEventListener('click',handleInteraction); be.addEventListener('touchstart',e=>{e.preventDefault();handleInteraction()});
        }
        function onWindowResize() { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); }
        function animate() { requestAnimationFrame(animate); updateGame(); renderer.render(scene, camera); }
        
        window.onload = init;
    </script>
</body>
</html>
